from __future__ import annotations

from typing import Dict, Optional

from parallax.agents.constitutions import NAVIGATOR_CONSTITUTION
from parallax.core.constitution import ConstitutionReport, ConstitutionViolation, FailureStore
from parallax.core.logging import get_logger
from parallax.core.metrics import workflow_failure
from parallax.core.schemas import ExecutionPlan


log = get_logger("navigator")


class Navigator:
    """
    Agent A2: Navigator - Executes plans in a live browser.
    
    The Navigator agent executes step-by-step plans generated by the Interpreter.
    It handles browser automation, element selection using semantic selectors,
    error recovery with retries, and vision-based fallbacks when selectors fail.
    
    Args:
        page: Playwright Page object for browser interaction
        observer: Optional Observer agent for capturing UI states
        default_wait_ms: Default wait time in milliseconds between actions
        failure_store: Optional store for tracking constitution failures
        vision_analyzer: Optional VisionAnalyzer for vision-based completion detection and element location
        task_context: Optional task context string for vision analysis
    
    Example:
        >>> from playwright.async_api import async_playwright
        >>> 
        >>> async with async_playwright() as p:
        ...     browser = await p.chromium.launch()
        ...     page = await browser.new_page()
        ...     navigator = Navigator(page, observer=observer)
        ...     await navigator.execute(plan, action_budget=30)
    """
    
    def __init__(
        self,
        page,
        observer=None,
        default_wait_ms: int = 1000,
        failure_store: Optional[FailureStore] = None,
        vision_analyzer=None,
        task_context: Optional[str] = None,
    ) -> None:
        self.page = page
        self.observer = observer
        self.default_wait_ms = default_wait_ms
        self.action_count = 0
        self.failure_store = failure_store
        self.constitution = NAVIGATOR_CONSTITUTION
        self.vision_analyzer = vision_analyzer
        self.task_context = task_context
        self._workflow_states = []

    async def execute(self, plan: ExecutionPlan, action_budget: int = 30) -> None:
        """
        Execute an execution plan in the browser.
        
        Executes each step of the plan sequentially, handling errors with retries
        and vision-based fallbacks. Monitors for completion using vision analysis
        if available, and checks for authentication redirects.
        
        Args:
            plan: ExecutionPlan with ordered steps to execute
            action_budget: Maximum number of actions to execute (default: 30)
        
        Raises:
            ConstitutionViolation: If navigation fails critical validation rules
        
        Example:
            >>> await navigator.execute(plan, action_budget=30)
            >>> print(f"Executed {navigator.action_count} actions")
        """
        steps = plan.steps[:action_budget]
        self.action_count = 0
        self._workflow_states = []
        
        for idx, step in enumerate(steps):
            if self.action_count >= action_budget:
                log.warning("action_budget_exceeded", budget=action_budget)
                break
            
            # Check for completion using vision analysis
            if self.vision_analyzer and self._workflow_states:
                try:
                    screenshot_bytes = await self.page.screenshot(full_page=False)
                    completion_analysis = await self.vision_analyzer.analyze_completion(
                        screenshot_bytes,
                        self.task_context or "",
                        self._workflow_states,
                    )
                    
                    if completion_analysis.get("is_complete", False):
                        confidence = completion_analysis.get("confidence", 0.0)
                        if confidence > 0.7:  # High confidence threshold
                            log.info(
                                "workflow_complete_vision",
                                confidence=confidence,
                                reasoning=completion_analysis.get("reasoning", ""),
                            )
                            break
                except Exception as e:
                    log.warning("vision_completion_check_failed", error=str(e))
            
            try:
                await self._run_step(step, retries=3)
                self.action_count += 1
                if self.observer is not None:
                    action_desc = self._describe_action(step)
                    state = await self.observer.observe(action_desc)
                    if state:
                        self._workflow_states.append(state.__dict__)
            except Exception as e:
                log.error("step_failed", step=step.action, error=str(e))
                workflow_failure.inc()
                
                # Try vision-based fallback if selector failed
                if self.vision_analyzer and step.action in ["click", "type", "submit"]:
                    try:
                        await self._run_step_vision_fallback(step)
                        self.action_count += 1
                        if self.observer is not None:
                            action_desc = self._describe_action(step)
                            state = await self.observer.observe(action_desc)
                            if state:
                                self._workflow_states.append(state.__dict__)
                        continue
                    except Exception as vision_error:
                        log.warning("vision_fallback_failed", error=str(vision_error))
                
                # Check for auth redirect
                if await self._check_auth_redirect():
                    log.warning("auth_redirect_detected")
                    # In production, would invoke re-auth hook
                    break
                # Continue with next step after error
                continue  # Continue to next iteration

    async def _run_step(self, step, retries: int = 3) -> None:
        action = step.action
        if action == "navigate" and step.target:
            await self.page.goto(step.target)
            await self.page.wait_for_load_state()
            return
        if action == "click":
            for attempt in range(retries):
                try:
                    locator = await self._resolve_locator_with_retry(step, attempt)
                    await locator.scroll_into_view_if_needed()
                    await locator.wait_for(state="visible", timeout=5000)
                    await locator.click()
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("click_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "type" and step.selector and step.value is not None:
            for attempt in range(retries):
                try:
                    loc = self.page.locator(step.selector)
                    await loc.wait_for(state="visible", timeout=5000)
                    await loc.fill(step.value)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("type_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "submit" and step.selector:
            for attempt in range(retries):
                try:
                    loc = self.page.locator(step.selector)
                    await loc.wait_for(state="visible", timeout=5000)
                    await loc.click()
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("submit_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return

    async def _resolve_locator_with_retry(self, step, attempt: int = 0):
        """Resolve locator with fallback strategies."""
        # Primary: role + name
        if step.role:
            if step.name:
                try:
                    return self.page.getByRole(step.role, name=step.name)
                except Exception:
                    pass
            try:
                return self.page.getByRole(step.role)
            except Exception:
                pass
        
        # Fallback: data-testid heuristic
        if step.selector and "data-testid" not in step.selector:
            # Try to find by data-testid if name matches common patterns
            if step.name:
                testid_variants = [
                    f'[data-testid="{step.name.lower().replace(" ", "-")}"]',
                    f'[data-testid="{step.name.lower().replace(" ", "_")}"]',
                    f'[data-testid*="{step.name.lower()}"]',
                ]
                for testid in testid_variants:
                    try:
                        loc = self.page.locator(testid)
                        if await loc.count() > 0:
                            return loc.first
                    except Exception:
                        continue
        
        # Fallback: CSS selector
        if step.selector:
            try:
                return self.page.locator(step.selector)
            except Exception:
                pass
        
        # Fallback: text match
        if step.name:
            try:
                return self.page.getByText(step.name, exact=False)
            except Exception:
                pass
        
        raise ValueError(f"Insufficient selector info for {step.action}")

    def _resolve_locator(self, step):
        """Legacy method - use _resolve_locator_with_retry instead."""
        if step.role:
            if step.name:
                return self.page.getByRole(step.role, name=step.name)
            return self.page.getByRole(step.role)
        if step.selector:
            return self.page.locator(step.selector)
        if step.name:
            return self.page.getByText(step.name, exact=False)
        raise ValueError("Insufficient selector info for click")

    async def _run_step_vision_fallback(self, step) -> None:
        """Execute step using vision-based element location (fallback)."""
        if not self.vision_analyzer:
            raise ValueError("Vision analyzer not available")
        
        # Get element description
        element_description = step.name or step.selector or f"{step.action} element"
        
        # Take screenshot
        screenshot_bytes = await self.page.screenshot(full_page=False)
        
        # Find element using vision
        vision_result = await self.vision_analyzer.find_element_vision(
            screenshot_bytes,
            element_description,
            step.action,
        )
        
        if not vision_result.get("element_found", False):
            raise ValueError(f"Vision could not locate element: {element_description}")
        
        confidence = vision_result.get("confidence", 0.0)
        if confidence < 0.7:
            log.warning("vision_low_confidence", confidence=confidence, description=element_description)
        
        x = vision_result.get("x", 0)
        y = vision_result.get("y", 0)
        
        # Execute action at coordinates
        if step.action == "click":
            await self.page.mouse.click(x, y)
        elif step.action == "type" and step.value is not None:
            await self.page.mouse.click(x, y)
            await self.page.keyboard.type(step.value)
        elif step.action == "submit":
            await self.page.mouse.click(x, y)
        else:
            raise ValueError(f"Vision fallback not supported for action: {step.action}")
        
        # Wait for page to stabilize
        await self.page.wait_for_timeout(self.default_wait_ms)
    
    async def _check_auth_redirect(self) -> bool:
        """Check if page redirected to login/auth page."""
        url = self.page.url
        auth_indicators = ["/login", "/auth", "/signin", "login", "signin"]
        return any(indicator in url.lower() for indicator in auth_indicators)

    def _describe_action(self, step) -> str:
        if step.action == "navigate":
            return f"navigate({step.target})"
        if step.action == "click":
            if step.role and step.name:
                return f"click({step.role}:{step.name})"
            if step.selector:
                return f"click({step.selector})"
            return "click"
        if step.action == "type":
            return f"type({step.selector})"
        if step.action == "submit":
            return f"submit({step.selector})"
        return step.action

    def finalize(self, plan: ExecutionPlan, context: Dict) -> ConstitutionReport:
        """
        Validate navigation results against the navigator constitution.

        Raises:
            ConstitutionViolation: If any critical validation rule fails.

        Returns:
            ConstitutionReport capturing any warnings that callers may surface.
        """
        report = self.constitution.validate(plan, None, context)

        if self.failure_store and (report.failures or report.warnings):
            self.failure_store.save_failure(report)

        if report.warnings:
            log.warning(
                "constitution_warnings",
                agent="A2_Navigator",
                warnings=[w.rule_name for w in report.warnings],
            )

        if not report.passed:
            failure_messages = [f"{f.rule_name}: {f.reason}" for f in report.failures]
            log.error(
                "constitution_failed",
                agent="A2_Navigator",
                failures=[f.rule_name for f in report.failures],
            )
            raise ConstitutionViolation(
                agent="A2_Navigator",
                failures=report.failures,
                message="Navigator constitution failed: " + "; ".join(failure_messages),
            )

        return report


