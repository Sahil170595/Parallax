from __future__ import annotations

import asyncio
import re
import unicodedata
from typing import TYPE_CHECKING, Any, Awaitable, Callable, Dict, Iterable, List, Optional, Sequence, Set

from playwright.async_api import Page

if TYPE_CHECKING:
    from parallax.agents.observer import Observer

from parallax.agents.constitutions import NAVIGATOR_CONSTITUTION
from parallax.agents.strategy_generator import StrategyGenerator, SelectorStrategy
from parallax.core.constitution import (
    ConstitutionReport,
    ConstitutionViolation,
    FailureStore,
    ValidationFailure,
)
from parallax.core.logging import get_logger
from parallax.core.metrics import workflow_failure
from parallax.core.schemas import ExecutionPlan


log = get_logger("navigator")


class Navigator:
    """
    Agent A2: Navigator - Executes plans in a live browser.
    
    The Navigator agent executes step-by-step plans generated by the Interpreter.
    It handles browser automation, element selection using semantic selectors,
    error recovery with retries, and vision-based fallbacks when selectors fail.
    
    Args:
        page: Playwright Page object for browser interaction
        observer: Optional Observer agent for capturing UI states
        default_wait_ms: Default wait time in milliseconds between actions
        scroll_margin_px: Margin used when scrolling page-level (default: 64)
        failure_store: Optional store for tracking constitution failures
        vision_analyzer: Optional VisionAnalyzer for vision-based completion detection and element location
        task_context: Optional task context string for vision analysis
        progress_callback: Optional callback for progress updates
    
    Example:
        >>> from playwright.async_api import async_playwright
        >>> 
        >>> async with async_playwright() as p:
        ...     browser = await p.chromium.launch()
        ...     page = await browser.new_page()
        ...     navigator = Navigator(page, observer=observer)
        ...     await navigator.execute(plan, action_budget=30)
    """
    
    # Constants for confidence thresholds and retry logic
    VISION_COMPLETION_CONFIDENCE_THRESHOLD = 0.7
    VISION_ELEMENT_CONFIDENCE_THRESHOLD = 0.7
    CLICK_RETRY_BASE_WAIT_MS = 500
    TYPE_RETRY_BASE_WAIT_MS = 500
    
    _SMART_TO_ASCII_TABLE = str.maketrans(
        "\u2018\u2019\u201a\u201c\u201d\u201e\u2013\u2014\u2011\u00a0",
        chr(39)*4 + chr(34)*3 + chr(45)*2 + chr(32),
    )
    _ASCII_TO_SMART_TABLE = str.maketrans(
        "'\"",
        "\u2019\u201d",  # smart apostrophe and quote
    )

    def __init__(
        self,
        page: Page,
        observer: Optional[Observer] = None,
        default_wait_ms: int = 1000,
        scroll_margin_px: int = 64,
        failure_store: Optional[FailureStore] = None,
        vision_analyzer: Optional[Any] = None,
        task_context: Optional[str] = None,
        progress_callback: Optional[Callable[[int, int, Any], Awaitable[None]]] = None,
        strategy_generator: Optional[StrategyGenerator] = None,
    ) -> None:
        self.page = page
        self.observer = observer
        self.default_wait_ms = default_wait_ms
        self.action_count = 0
        self.failure_store = failure_store
        self.constitution = NAVIGATOR_CONSTITUTION
        self.vision_analyzer = vision_analyzer
        self.task_context = task_context
        self.progress_callback = progress_callback
        self.strategy_generator = strategy_generator
        self._workflow_states = []
        try:
            self.scroll_margin_px = max(0, int(scroll_margin_px))
        except (TypeError, ValueError):
            self.scroll_margin_px = 64

    async def execute(
        self,
        plan: ExecutionPlan,
        action_budget: int = 30,
        cancellation_token: Optional[asyncio.CancelledError] = None,
    ) -> None:
        """
        Execute an execution plan in the browser.
        
        Executes each step of the plan sequentially, handling errors with retries
        and vision-based fallbacks. Monitors for completion using vision analysis
        if available, and checks for authentication redirects.
        
        Args:
            plan: ExecutionPlan with ordered steps to execute
            action_budget: Maximum number of actions to execute (default: 30)
        
        Raises:
            ConstitutionViolation: If navigation fails critical validation rules
        
        Example:
            >>> await navigator.execute(plan, action_budget=30)
            >>> print(f"Executed {navigator.action_count} actions")
        """
        steps = plan.steps[:action_budget]
        self.action_count = 0
        self._workflow_states = []
        total_steps = len(steps) or 1

        for idx, step in enumerate(steps):
            # Check for cancellation
            if cancellation_token:
                try:
                    cancellation_token.check_cancelled()
                except AttributeError:
                    # If cancellation_token doesn't have check_cancelled, check manually
                    if hasattr(cancellation_token, 'is_cancelled') and cancellation_token.is_cancelled():
                        log.info("workflow_cancelled", steps_completed=idx, total_steps=total_steps)
                        raise asyncio.CancelledError("Workflow cancelled by user")
            
            if self.action_count >= action_budget:
                log.warning("action_budget_exceeded", budget=action_budget)
                break

            if self.progress_callback:
                try:
                    # Ensure progress values are valid: clamp idx to [0, total_steps-1]
                    safe_idx = min(max(0, idx), max(0, total_steps - 1))
                    safe_total = max(1, total_steps)
                    progress_result = self.progress_callback(safe_idx + 1, safe_total, step)
                    if asyncio.iscoroutine(progress_result):
                        await progress_result
                except Exception as exc:
                    log.warning("navigator_progress_callback_failed", error=str(exc), error_type=type(exc).__name__)
            
            # Check for completion using vision analysis
            if self.vision_analyzer and self._workflow_states:
                try:
                    screenshot_bytes = await self.page.screenshot(full_page=False)
                    completion_analysis = await self.vision_analyzer.analyze_completion(
                        screenshot_bytes,
                        self.task_context or "",
                        self._workflow_states,
                    )
                    
                    if completion_analysis.get("is_complete", False):
                        confidence = completion_analysis.get("confidence", 0.0)
                        if confidence > Navigator.VISION_COMPLETION_CONFIDENCE_THRESHOLD:
                            log.info(
                                "workflow_complete_vision",
                                confidence=confidence,
                                reasoning=completion_analysis.get("reasoning", ""),
                            )
                            break
                except Exception as e:
                    log.warning("vision_completion_check_failed", error=str(e))
            
            try:
                await self._run_step(step, retries=3)
                self.action_count += 1
                if self.observer is not None:
                    action_desc = self._describe_action(step)
                    state = await self.observer.observe(action_desc)
                    if state:
                        self._workflow_states.append(state)
            except Exception as e:
                log.error("step_failed", step=step.action, error=str(e), step_details={
                    "action": step.action,
                    "target": step.target,
                    "selector": step.selector,
                    "name": step.name,
                    "role": step.role
                })
                workflow_failure.inc()
                
                # Capture state even when step fails (for debugging)
                if self.observer is not None:
                    action_desc = self._describe_action(step) + " [FAILED]"
                    try:
                        state = await self.observer.observe(action_desc)
                        if state:
                            self._workflow_states.append(state)
                    except Exception:
                        pass  # If state capture also fails, continue
                
                # Try strategy-based fallback if available
                if self.strategy_generator and step.action in ["click", "type", "select", "hover", "focus"]:
                    try:
                        log.info("trying_strategy_fallback", step=step.action)
                        website_pattern = self.page.url.split("/")[2] if self.page.url else None
                        improved_step = self.strategy_generator.suggest_improved_step(
                            step,
                            str(e),
                            website_pattern,
                        )
                        if improved_step:
                            await self._run_step(improved_step, retries=2)
                            self.action_count += 1
                            if self.observer is not None:
                                action_desc = self._describe_action(improved_step)
                                state = await self.observer.observe(action_desc)
                                if state:
                                    self._workflow_states.append(state)
                            # Record strategy success
                            if step.name or step.selector:
                                element_desc = step.name or step.selector or ""
                                strategies = self.strategy_generator.get_best_strategies(
                                    element_desc,
                                    website_pattern,
                                limit=1,
                                step=step,
                                )
                                if strategies:
                                    self.strategy_generator.record_strategy_result(
                                        strategies[0],
                                        True,
                                        element_desc,
                                    website_pattern,
                                    step=step,
                                    )
                            continue
                    except Exception as strategy_error:
                        log.warning("strategy_fallback_failed", error=str(strategy_error))
                        # Record strategy failure
                        if self.strategy_generator and (step.name or step.selector):
                            element_desc = step.name or step.selector or ""
                            website_pattern = self.page.url.split("/")[2] if self.page.url else None
                            strategies = self.strategy_generator.get_best_strategies(
                                element_desc,
                                website_pattern,
                                limit=1,
                                step=step,
                            )
                            if strategies:
                                self.strategy_generator.record_strategy_result(
                                    strategies[0],
                                    False,
                                    element_desc,
                                    website_pattern,
                                    step=step,
                                )
                
                # Try vision-based fallback if selector failed
                if self.vision_analyzer and step.action in ["click", "type", "submit"]:
                    try:
                        log.info("trying_vision_fallback", step=step.action)
                        await self._run_step_vision_fallback(step)
                        self.action_count += 1
                        if self.observer is not None:
                            action_desc = self._describe_action(step)
                            state = await self.observer.observe(action_desc)
                            if state:
                                self._workflow_states.append(state.__dict__)
                        continue
                    except Exception as vision_error:
                        log.warning("vision_fallback_failed", error=str(vision_error))
                
                # Check for auth redirect
                if await self._check_auth_redirect():
                    log.warning("auth_redirect_detected")
                    # In production, would invoke re-auth hook
                    break
                
                # For click actions, log more details about the failure
                if step.action == "click":
                    log.warning("click_action_failed", 
                               selector=step.selector,
                               name=step.name,
                               role=step.role,
                               error=str(e))
                
                # Continue with next step after error
                continue  # Continue to next iteration

    async def _run_step(self, step, retries: int = 3) -> None:
        action = step.action
        if action == "navigate" and step.target:
            await self._robust_navigate(step.target)
            return
        if action == "wait":
            await self._run_wait(step)
            return
        if action == "scroll":
            await self._run_scroll(step)
            return
        if action == "click":
            for attempt in range(retries):
                try:
                    locator = await self._resolve_locator_with_retry(step, attempt)
                    locator = await self._maybe_reveal_hidden(locator, step)
                    # Handle multiple matches by using first if selector is used
                    if step.selector and await locator.count() > 1:
                        locator = locator.first
                    
                    # Dismiss modals that might block the click
                    await self._dismiss_modals_if_safe()
                    
                    # Wait for element to be stable and interactable
                    await self._wait_for_element_stable(locator, timeout=5000)
                    await self._wait_for_interactable(locator, timeout=5000)
                    await locator.scroll_into_view_if_needed()
                    
                    # Get href to check if it's an external link
                    href = await locator.get_attribute("href")
                    target = await locator.get_attribute("target")
                    current_url = self.page.url
                    
                    # Try normal click with navigation wait
                    try:
                        # Check if link opens in new tab/window
                        if target == "_blank":
                            # Handle new tab/window
                            async with self.page.context.expect_page(timeout=5000) as new_page_info:
                                await locator.click(timeout=5000)
                            new_page = await new_page_info.value
                            await new_page.wait_for_load_state("networkidle")
                            # Switch to the new page and update observer reference
                            self.page = new_page
                            if self.observer is not None:
                                self.observer.page = new_page
                        elif href and (href.startswith("http") or href.startswith("//")):
                            # External link - wait for navigation
                            try:
                                async with self.page.expect_navigation(timeout=15000, wait_until="networkidle"):
                                    await locator.click(timeout=5000)
                            except Exception:
                                # If networkidle times out, try domcontentloaded
                                async with self.page.expect_navigation(timeout=15000, wait_until="domcontentloaded"):
                                    await locator.click(timeout=5000)
                                # Wait a bit more for JS to finish
                                await self.page.wait_for_timeout(2000)
                        else:
                            # Same-page navigation - wait for navigation
                            try:
                                async with self.page.expect_navigation(timeout=10000, wait_until="networkidle"):
                                    await locator.click(timeout=5000)
                            except Exception:
                                # If networkidle times out, try domcontentloaded
                                async with self.page.expect_navigation(timeout=10000, wait_until="domcontentloaded"):
                                    await locator.click(timeout=5000)
                                await self.page.wait_for_timeout(1000)
                    except Exception as nav_error:
                        # If navigation wait fails, try click without wait
                        try:
                            await locator.click(timeout=5000)
                            # Wait for potential navigation
                            await self.page.wait_for_timeout(2000)
                            # Check if URL changed
                            new_url = self.page.url
                            if new_url != current_url:
                                # URL changed, wait for load
                                try:
                                    await self.page.wait_for_load_state("networkidle", timeout=5000)
                                except Exception:
                                    await self.page.wait_for_load_state("domcontentloaded", timeout=5000)
                        except Exception as click_error:
                            # If click is intercepted, try force click
                            try:
                                await locator.click(force=True, timeout=5000)
                                await self.page.wait_for_timeout(2000)
                                # Check if URL changed after force click
                                new_url = self.page.url
                                if new_url != current_url:
                                    try:
                                        await self.page.wait_for_load_state("networkidle", timeout=5000)
                                    except Exception:
                                        await self.page.wait_for_load_state("domcontentloaded", timeout=5000)
                            except Exception as force_error:
                                log.warning("click_failed_after_all_attempts", error=str(force_error))
                                raise
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    # Exponential backoff: wait longer on each retry
                    wait_time = Navigator.CLICK_RETRY_BASE_WAIT_MS * (2 ** attempt)
                    log.warning("click_retry", attempt=attempt + 1, error=str(e), wait_ms=wait_time)
                    await self.page.wait_for_timeout(wait_time)
            return
        if action == "type" and step.value is not None:
            for attempt in range(retries):
                try:
                    # Dismiss modals first
                    await self._dismiss_modals_if_safe()
                    
                    loc = await self._resolve_locator_with_retry(step, attempt)
                    await self._wait_for_interactable(loc, timeout=5000)
                    
                    # Clear field first if needed
                    await loc.click(timeout=2000)
                    await loc.fill("")  # Clear existing content
                    await loc.fill(step.value)
                    
                    # Verify value was set
                    actual_value = await loc.input_value()
                    if actual_value != step.value:
                        # Try again with clear and type
                        await loc.click(timeout=2000)
                        await loc.fill("")
                        await loc.type(step.value, delay=50)  # Type with delay for slow inputs
                    
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    wait_time = Navigator.TYPE_RETRY_BASE_WAIT_MS * (2 ** attempt)
                    log.warning("type_retry", attempt=attempt + 1, error=str(e), wait_ms=wait_time)
                    await self.page.wait_for_timeout(wait_time)
            return
        if action == "submit" and step.selector:
            for attempt in range(retries):
                try:
                    loc = self.page.locator(step.selector)
                    await loc.wait_for(state="visible", timeout=5000)
                    await loc.click()
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("submit_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "select" and step.selector and (step.value or step.option_value):
            for attempt in range(retries):
                try:
                    loc = self.page.locator(step.selector)
                    await loc.wait_for(state="visible", timeout=5000)
                    option_value = step.option_value or step.value
                    await loc.select_option(option_value)
                    await self.page.wait_for_timeout(self.default_wait_ms)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("select_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "drag" and step.start_selector and (step.end_selector or step.target):
            for attempt in range(retries):
                try:
                    start_loc = self.page.locator(step.start_selector)
                    end_loc = self.page.locator(step.end_selector) if step.end_selector else self.page.locator(step.target)
                    await start_loc.wait_for(state="visible", timeout=5000)
                    await end_loc.wait_for(state="visible", timeout=5000)
                    await start_loc.drag_to(end_loc)
                    await self.page.wait_for_timeout(self.default_wait_ms)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("drag_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "upload" and step.selector and (step.file_path or step.value):
            for attempt in range(retries):
                try:
                    loc = self.page.locator(step.selector)
                    await loc.wait_for(state="visible", timeout=5000)
                    file_path = step.file_path or step.value
                    await loc.set_input_files(file_path)
                    await self.page.wait_for_timeout(self.default_wait_ms)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("upload_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "hover" and step.selector:
            for attempt in range(retries):
                try:
                    loc = await self._resolve_locator_with_retry(step, attempt)
                    await loc.wait_for(state="visible", timeout=5000)
                    await loc.hover()
                    await self.page.wait_for_timeout(self.default_wait_ms)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("hover_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "double_click" and step.selector:
            for attempt in range(retries):
                try:
                    loc = await self._resolve_locator_with_retry(step, attempt)
                    await loc.wait_for(state="visible", timeout=5000)
                    await loc.dblclick()
                    await self.page.wait_for_timeout(self.default_wait_ms)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("double_click_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "right_click" and step.selector:
            for attempt in range(retries):
                try:
                    loc = await self._resolve_locator_with_retry(step, attempt)
                    await loc.wait_for(state="visible", timeout=5000)
                    await loc.click(button="right")
                    await self.page.wait_for_timeout(self.default_wait_ms)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("right_click_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "fill" and step.selector and step.value:
            for attempt in range(retries):
                try:
                    loc = self.page.locator(step.selector)
                    await loc.wait_for(state="visible", timeout=5000)
                    await loc.fill(step.value)
                    await self.page.wait_for_timeout(self.default_wait_ms)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("fill_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "check" and step.selector:
            for attempt in range(retries):
                try:
                    loc = self.page.locator(step.selector)
                    await loc.wait_for(state="visible", timeout=5000)
                    await loc.check()
                    await self.page.wait_for_timeout(self.default_wait_ms)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("check_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "uncheck" and step.selector:
            for attempt in range(retries):
                try:
                    loc = self.page.locator(step.selector)
                    await loc.wait_for(state="visible", timeout=5000)
                    await loc.uncheck()
                    await self.page.wait_for_timeout(self.default_wait_ms)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("uncheck_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "focus":
            for attempt in range(retries):
                try:
                    loc = await self._resolve_locator_with_retry(step, attempt)
                    await loc.wait_for(state="visible", timeout=5000)
                    await loc.focus()
                    await self.page.wait_for_timeout(self.default_wait_ms)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("focus_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action == "blur" and step.selector:
            for attempt in range(retries):
                try:
                    loc = self.page.locator(step.selector)
                    await loc.wait_for(state="visible", timeout=5000)
                    await loc.evaluate("element => element.blur()")
                    await self.page.wait_for_timeout(self.default_wait_ms)
                    return
                except Exception as e:
                    if attempt == retries - 1:
                        raise
                    log.warning("blur_retry", attempt=attempt + 1, error=str(e))
                    await self.page.wait_for_timeout(500)
            return
        if action in ("key_press", "press_key") and step.value:
            try:
                await self.page.keyboard.press(step.value)
                await self.page.wait_for_timeout(self.default_wait_ms)
                return
            except Exception as e:
                log.warning("key_press_failed", key=step.value, error=str(e))
                raise
        if action == "go_back":
            try:
                await self.page.go_back()
                await self.page.wait_for_load_state("networkidle", timeout=10000)
                return
            except Exception as e:
                log.warning("go_back_failed", error=str(e))
                raise
        if action == "go_forward":
            try:
                await self.page.go_forward()
                await self.page.wait_for_load_state("networkidle", timeout=10000)
                return
            except Exception as e:
                log.warning("go_forward_failed", error=str(e))
                raise
        if action == "reload":
            try:
                await self.page.reload(wait_until="networkidle", timeout=30000)
                return
            except Exception as e:
                log.warning("reload_failed", error=str(e))
                raise
        if action == "screenshot":
            try:
                screenshot_path = step.value or step.target or "screenshot.png"
                await self.page.screenshot(path=screenshot_path, full_page=step.selector is None)
                return
            except Exception as e:
                log.warning("screenshot_failed", error=str(e))
                raise
        if action == "evaluate" and step.value:
            try:
                result = await self.page.evaluate(step.value)
                log.debug("evaluate_result", result=str(result)[:100])
                return
            except Exception as e:
                log.warning("evaluate_failed", error=str(e))
                raise

    async def _robust_navigate(self, url: str) -> None:
        """Navigate to URL with multiple fallback strategies."""
        max_attempts = 3
        for attempt in range(max_attempts):
            try:
                # Try navigation with networkidle wait
                await self.page.goto(url, wait_until="networkidle", timeout=30000)
                # Verify navigation succeeded
                await self.page.wait_for_load_state("networkidle", timeout=5000)
                return
            except Exception as e:
                if attempt == max_attempts - 1:
                    # Last attempt: try with domcontentloaded
                    try:
                        await self.page.goto(url, wait_until="domcontentloaded", timeout=30000)
                        await self.page.wait_for_timeout(2000)  # Give JS time to run
                        return
                    except Exception as final_error:
                        log.warning("navigation_failed_all_attempts", url=url, error=str(final_error))
                        raise
                log.warning("navigation_retry", attempt=attempt + 1, url=url, error=str(e))
                await self.page.wait_for_timeout(1000 * (attempt + 1))  # Exponential backoff

    async def _dismiss_modals_if_safe(self) -> None:
        """Attempt to dismiss common modals/popups that might block interactions."""
        try:
            # Check for common modal patterns
            modal_selectors = [
                '[role="dialog"]',
                '[role="alertdialog"]',
                '.modal',
                '.popup',
                '[data-modal]',
                '[data-popup]',
            ]
            
            for selector in modal_selectors:
                try:
                    modal_locator = self.page.locator(selector)
                    modal_count = await modal_locator.count()
                    if modal_count > 0:
                        modal = modal_locator.first
                        # Look for close button
                        close_selectors = [
                            'button[aria-label*="close" i]',
                            'button[aria-label*="dismiss" i]',
                            'button.close',
                            '[data-dismiss="modal"]',
                            'button:has-text("Close")',
                            'button:has-text("Ã—")',
                        ]
                        for close_sel in close_selectors:
                            try:
                                close_btn_locator = modal.locator(close_sel)
                                if await close_btn_locator.count() > 0:
                                    close_btn = close_btn_locator.first
                                    await close_btn.click(timeout=2000)
                                    await self.page.wait_for_timeout(500)
                                    log.info("dismissed_modal", selector=selector, close_button=close_sel)
                                    return
                            except Exception:
                                continue
                except Exception:
                    continue
        except Exception as e:
            log.debug("modal_dismiss_failed", error=str(e))

    async def _wait_for_element_stable(self, locator, timeout: int = 5000) -> None:
        """Wait for element to be stable (not moving, not changing size)."""
        try:
            # Wait for element to be visible
            await locator.wait_for(state="visible", timeout=timeout)
            
            # Wait for element to be stable (not animating)
            for _ in range(5):  # Check 5 times
                await self.page.wait_for_timeout(200)
                # Element should be in viewport and stable
                box = await locator.bounding_box()
                if box:
                    # Check if element is reasonably sized and positioned
                    if box['width'] > 0 and box['height'] > 0:
                        break
        except Exception:
            pass  # If stability check fails, continue anyway

    async def _wait_for_interactable(self, locator, timeout: int = 5000) -> None:
        """Wait for element to be interactable (visible, enabled, not covered)."""
        try:
            await locator.wait_for(state="visible", timeout=timeout)
            # Check if element is enabled
            is_disabled = await locator.get_attribute("disabled")
            if is_disabled:
                raise ValueError("Element is disabled")
            # Check if element is not covered by overlay
            try:
                await locator.scroll_into_view_if_needed()
            except Exception:
                pass
        except Exception as e:
            log.debug("wait_for_interactable_failed", error=str(e))
            raise

    async def _maybe_reveal_hidden(self, locator, step):
        """If locator is hidden, try to reveal dropdown/menu items."""
        try:
            if await locator.is_visible():
                return locator
        except Exception:
            pass

        name = getattr(step, "name", None)
        if step.role == "link" and name:
            candidates = [
                self.page.get_by_role("button", name=name, exact=False),
                self.page.get_by_role("menuitem", name=name, exact=False),
                self.page.locator(f"[aria-label*=\"{name}\"]"),
                self.page.locator(f"[data-track-label*=\"{name}\"]"),
            ]
            for candidate in candidates:
                try:
                    if await candidate.count() == 0:
                        continue
                    toggle = candidate.first
                    if not await toggle.is_visible():
                        continue
                    await toggle.hover()
                    try:
                        await toggle.click()
                    except Exception:
                        pass
                    await self.page.wait_for_timeout(200)
                    refreshed = await self._resolve_locator_with_retry(step, 0)
                    try:
                        if await refreshed.is_visible():
                            return refreshed
                    except Exception:
                        continue
                except Exception:
                    continue
        return locator

    async def _resolve_locator_with_retry(self, step, attempt: int = 0):
        """Resolve locator with multiple resilient strategies."""
        variants = self._text_variants(step.name) if step.name else []

        # Role-based resolution
        if step.role:
            if variants:
                locator = await self._first_matching_locator(
                    self._role_locators(step.role, variants)
                )
                if locator:
                    return locator
            else:
                locator = await self._first_matching_locator(
                    [self.page.get_by_role(step.role)]
                )
                if locator:
                    return locator

        # data-testid heuristics derived from text
        if variants:
            locator = await self._resolve_data_testid(variants)
            if locator:
                return locator

        # Direct selector fallback
        if step.selector:
            try:
                locator = await self._first_matching_locator(
                    [self.page.locator(step.selector)],
                    allow_empty=True,
                )
                if locator:
                    return locator
            except Exception as exc:
                log.debug("navigator_selector_lookup_failed", selector=step.selector, error=str(exc))

        # Text-based fallbacks (regex, has-text, etc.)
        if variants:
            locator = await self._first_matching_locator(
                self._text_locators(variants, preferred_role=step.role)
            )
            if locator:
                return locator
            locator = await self._first_matching_locator(
                self._xpath_locators(variants, preferred_role=step.role)
            )
            if locator:
                return locator

        await self._log_locator_diagnostics(step, variants)
        raise ValueError(f"Insufficient selector info for {step.action}")

    def _resolve_locator(self, step):
        """Legacy method - use _resolve_locator_with_retry instead."""
        if step.role:
            if step.name:
                return self.page.get_by_role(step.role, name=step.name)
            return self.page.get_by_role(step.role)
        if step.selector:
            return self.page.locator(step.selector)
        if step.name:
            return self.page.get_by_text(step.name, exact=False)
        raise ValueError("Insufficient selector info for click")

    def _role_locators(self, role: str, variants: Iterable[str]):
        """Generate locator candidates based on role and text variants."""
        regex_cache: Dict[str, re.Pattern[str]] = {}
        for variant in variants:
            yield self.page.get_by_role(role, name=variant, exact=True)
            yield self.page.get_by_role(role, name=variant, exact=False)
            regex = regex_cache.setdefault(variant, self._text_regex(variant))
            yield self.page.get_by_role(role, name=regex)
            try:
                yield self.page.get_by_role(role).filter(has_text=regex)
            except Exception:
                pass
            for selector in self._role_selector_candidates(role):
                try:
                    yield self.page.locator(selector).filter(has_text=regex)
                except Exception:
                    continue

    def _text_locators(self, variants: Iterable[str], preferred_role: Optional[str]):
        """Generate locator candidates based on text variants."""
        for variant in variants:
            regex = self._text_regex(variant)
            attr_literal = self._selector_literal(variant)
            locators = [
                self.page.get_by_text(variant, exact=True),
                self.page.get_by_text(variant, exact=False),
                self.page.get_by_text(regex),
                self.page.locator(f"text={self._selector_literal(variant)}"),
                self.page.locator(f"[aria-label={attr_literal}]"),
                self.page.locator(f"[aria-label*={attr_literal}]"),
                self.page.locator(f"[title={attr_literal}]"),
                self.page.locator(f"[title*={attr_literal}]"),
            ]
            for selector in self._role_selector_candidates(preferred_role):
                try:
                    locators.append(self.page.locator(selector).filter(has_text=regex))
                except Exception:
                    continue
            try:
                locators.append(self.page.locator("a").filter(has_text=regex))
            except Exception:
                pass
            try:
                locators.append(self.page.locator('[role="link"]').filter(has_text=regex))
            except Exception:
                pass
            try:
                locators.append(self.page.locator('[aria-label]').filter(has_text=regex))
            except Exception:
                pass
            try:
                locators.append(self.page.locator('[title]').filter(has_text=regex))
            except Exception:
                pass
            for locator in locators:
                yield locator

    def _xpath_locators(self, variants: Iterable[str], preferred_role: Optional[str]):
        """Generate XPath-based fallback locators."""
        conditions = self._role_xpath_conditions(preferred_role)
        predicate = " or ".join(conditions) if conditions else None
        for variant in variants:
            literal = self._xpath_literal(variant)
            if predicate:
                yield self.page.locator(f"xpath=//*[{predicate}][normalize-space(.)={literal}]")
                yield self.page.locator(f"xpath=//*[{predicate}][contains(normalize-space(.), {literal})]")
            else:
                yield self.page.locator(f"xpath=//*[normalize-space(.)={literal}]")
                yield self.page.locator(f"xpath=//*[contains(normalize-space(.), {literal})]")

    def _role_selector_candidates(self, role: Optional[str]) -> List[str]:
        if not role:
            return []
        role_map = {
            "link": ["a", '[role="link"]'],
            "button": ["button", '[role="button"]', "input[type='button']", "input[type='submit']"],
            "menuitem": ['[role="menuitem"]'],
            "tab": ['[role="tab"]'],
            "checkbox": ["input[type='checkbox']", '[role="checkbox"]'],
            "radio": ["input[type='radio']", '[role="radio"]'],
            "option": ["option", '[role="option"]'],
        }
        selectors = role_map.get(role)
        if selectors:
            return selectors
        return [f'[role="{role}"]']

    def _role_xpath_conditions(self, role: Optional[str]) -> List[str]:
        base_conditions = ["self::a", "@role='link'", "@role='button'", "self::button", "self::input[@type='button']", "self::input[@type='submit']"]
        if not role:
            return base_conditions
        role_map = {
            "link": ["self::a", "@role='link'"],
            "button": ["self::button", "@role='button'", "self::input[@type='button']", "self::input[@type='submit']"],
            "menuitem": ["@role='menuitem'"],
            "tab": ["@role='tab'"],
            "checkbox": ["@role='checkbox'", "self::input[@type='checkbox']"],
            "radio": ["@role='radio'", "self::input[@type='radio']"],
            "option": ["@role='option'", "self::option"],
        }
        return role_map.get(role, base_conditions)

    def _selector_literal(self, text: str) -> str:
        escaped = (
            text.replace("\\", "\\\\")
            .replace('"', '\\"')
            .replace("`", "\\`")
            .replace("\n", "\\A ")
        )
        return f'"{escaped}"'

    def _xpath_literal(self, text: str) -> str:
        if "'" not in text:
            return f"'{text}'"
        if '"' not in text:
            return f'"{text}"'
        parts = text.split("'")
        concat_parts = []
        for idx, part in enumerate(parts):
            if part:
                concat_parts.append(f"'{part}'")
            if idx != len(parts) - 1:
                concat_parts.append('"\'"')
        return "concat(" + ", ".join(concat_parts) + ")"

    def _text_regex(self, text: str) -> re.Pattern[str]:
        return re.compile(re.escape(text), re.IGNORECASE)

    async def _first_matching_locator(self, locators: Iterable[Any], allow_empty: bool = False) -> Optional[Any]:
        for locator in locators:
            if locator is None:
                continue
            try:
                count = await locator.count()
            except Exception as exc:
                log.debug("navigator_locator_count_failed", error=str(exc))
                continue
            if count > 0:
                try:
                    return locator.first if count > 1 else locator
                except Exception:
                    return locator
            if allow_empty:
                return locator
        return None

    async def _resolve_data_testid(self, variants: Iterable[str]) -> Optional[Any]:
        selectors: List[str] = []
        seen: Set[str] = set()
        for variant in variants:
            base = self._collapse_whitespace(variant).lower()
            if not base:
                continue
            ascii_base = base.translate(self._SMART_TO_ASCII_TABLE)
            for value in {base, ascii_base}:
                if not value:
                    continue
                dash = value.replace(" ", "-")
                underscore = value.replace(" ", "_")
                for selector in (
                    f'[data-testid="{dash}"]',
                    f'[data-testid="{underscore}"]',
                    f'[data-testid*="{value}"]',
                ):
                    if selector not in seen:
                        seen.add(selector)
                        selectors.append(selector)
        if not selectors:
            return None
        locator_candidates = []
        for selector in selectors:
            try:
                locator_candidates.append(self.page.locator(selector))
            except Exception as exc:
                log.debug("navigator_data_testid_selector_failed", selector=selector, error=str(exc))
        if not locator_candidates:
            return None
        return await self._first_matching_locator(locator_candidates)

    async def _log_locator_diagnostics(self, step, variants: List[str]) -> None:
        try:
            sample_texts: List[str] = []
            if step.role:
                try:
                    sample_locator = self.page.get_by_role(step.role)
                    sample_texts = await sample_locator.all_inner_texts()
                except Exception:
                    sample_texts = []
            log.debug(
                "navigator_locator_debug",
                action=step.action,
                role=step.role,
                selector=step.selector,
                name=step.name,
                variants=variants[:5],
                sample_texts=[self._collapse_whitespace(s) for s in sample_texts[:10]],
            )
        except Exception as exc:
            log.debug("navigator_locator_debug_failed", error=str(exc))

    def _text_variants(self, text: str) -> List[str]:
        variants: List[str] = []
        seen: Set[str] = set()

        def add(candidate: str) -> None:
            collapsed = self._collapse_whitespace(candidate)
            if collapsed and collapsed not in seen:
                seen.add(collapsed)
                variants.append(collapsed)

        base = str(text)
        normalized = unicodedata.normalize("NFKC", base)
        add(base)
        add(normalized)
        add(base.translate(self._SMART_TO_ASCII_TABLE))
        add(normalized.translate(self._SMART_TO_ASCII_TABLE))
        add(base.translate(self._ASCII_TO_SMART_TABLE))
        add(normalized.translate(self._ASCII_TO_SMART_TABLE))
        add(base.lower())
        add(base.casefold())
        add(base.title())
        return variants

    def _collapse_whitespace(self, text: str) -> str:
        return re.sub(r"\s+", " ", text).strip()

    async def _run_wait(self, step) -> None:
        """Pause execution for a specified duration (milliseconds)."""
        duration_ms = self._parse_wait_duration(step)
        if duration_ms < 0:
            duration_ms = self.default_wait_ms
        await self.page.wait_for_timeout(duration_ms)

    def _parse_wait_duration(self, step) -> int:
        """Parse wait duration from plan step."""
        raw = step.value or step.target
        if raw is None:
            return self.default_wait_ms
        try:
            if isinstance(raw, (int, float)):
                return max(0, int(float(raw)))
            text = str(raw).strip().lower()
            if text.endswith("ms"):
                text = text[:-2].strip()
                return max(0, int(float(text)))
            if text.endswith("s"):
                text = text[:-1].strip()
                return max(0, int(float(text) * 1000))
            return max(0, int(float(text)))
        except (ValueError, TypeError):
            log.warning("navigator_wait_parse_failed", value=str(raw))
            return self.default_wait_ms

    async def _run_scroll(self, step) -> None:
        """Scroll viewport or element according to plan step."""
        locator = await self._resolve_scroll_locator(step)
        if locator is not None:
            try:
                await locator.scroll_into_view_if_needed()
                await self.page.wait_for_timeout(200)
                return
            except Exception as exc:
                log.debug("navigator_scroll_element_failed", error=str(exc))
        
        # Fallback to page-level scrolling
        await self._fallback_scroll(step)

    async def _resolve_scroll_locator(self, step) -> Optional[Any]:
        """Resolve locator for scroll action if specified."""
        try:
            if step.selector:
                loc = self.page.locator(step.selector)
                if await loc.count() > 0:
                    return loc.first
            if step.role:
                if step.name:
                    loc = self.page.get_by_role(step.role, name=step.name)
                else:
                    loc = self.page.get_by_role(step.role)
                if await loc.count() > 0:
                    return loc.first
            if step.name and not step.selector and not step.role:
                loc = self.page.get_by_text(step.name, exact=False)
                if await loc.count() > 0:
                    return loc.first
        except Exception as exc:
            log.debug("navigator_scroll_locator_unresolved", error=str(exc))
        return None

    async def _fallback_scroll(self, step) -> None:
        """Fallback scrolling using window scrolling."""
        direction = step.value or "down"
        pixels = self._parse_scroll_pixels(step.value)
        
        if pixels is None:
            # Default to viewport-based scrolling
            viewport_height = self.page.viewport_size.get("height", 900) if self.page.viewport_size else 900
            pixels = viewport_height - self.scroll_margin_px
        
        if direction.lower() == "up":
            pixels = -pixels
        
        script = f"window.scrollBy(0, {pixels})"
        await self.page.evaluate(script)
        await self.page.wait_for_timeout(200)

    def _parse_scroll_pixels(self, text: Optional[str]) -> Optional[int]:
        """Parse scroll pixels from plan step value."""
        if text is None:
            return None
        try:
            if isinstance(text, (int, float)):
                return int(text)
            text_str = str(text).strip().lower()
            if text_str in ["up", "down"]:
                return None  # Will use viewport-based calculation
            if text_str.endswith("px"):
                return int(float(text_str[:-2]))
            if text_str.endswith("%"):
                value = float(text_str[:-1]) / 100.0
                return int(value * (self.page.viewport_size["height"] if self.page.viewport_size else 1))
            return int(text)
        except (ValueError, TypeError, KeyError, AttributeError):
            return None

    async def _run_step_vision_fallback(self, step) -> None:
        """Execute step using vision-based element location (fallback)."""
        if not self.vision_analyzer:
            raise ValueError("Vision analyzer not available")
        
        # Get element description
        element_description = step.name or step.selector or f"{step.action} element"
        
        # Take screenshot
        screenshot_bytes = await self.page.screenshot(full_page=False)
        
        # Find element using vision
        vision_result = await self.vision_analyzer.find_element_vision(
            screenshot_bytes,
            element_description,
            step.action,
        )
        
        if not vision_result.get("element_found", False):
            raise ValueError(f"Vision could not locate element: {element_description}")
        
        confidence = vision_result.get("confidence", 0.0)
        if confidence < Navigator.VISION_ELEMENT_CONFIDENCE_THRESHOLD:
            log.warning("vision_low_confidence", confidence=confidence, description=element_description)
        
        x = vision_result.get("x", 0)
        y = vision_result.get("y", 0)
        
        # Execute action at coordinates
        if step.action == "click":
            await self.page.mouse.click(x, y)
        elif step.action == "type" and step.value is not None:
            await self.page.mouse.click(x, y)
            await self.page.keyboard.type(step.value)
        elif step.action == "submit":
            await self.page.mouse.click(x, y)
        else:
            raise ValueError(f"Vision fallback not supported for action: {step.action}")
        
        # Wait for page to stabilize
        await self.page.wait_for_timeout(self.default_wait_ms)
    
    async def _check_auth_redirect(self) -> bool:
        """Check if page redirected to login/auth page."""
        url = self.page.url
        auth_indicators = ["/login", "/auth", "/signin", "login", "signin"]
        return any(indicator in url.lower() for indicator in auth_indicators)

    def _describe_action(self, step) -> str:
        if step.action == "navigate":
            return f"navigate({step.target})"
        if step.action == "click":
            if step.role and step.name:
                return f"click({step.role}:{step.name})"
            if step.selector:
                return f"click({step.selector})"
            return "click"
        if step.action == "type":
            return f"type({step.selector})"
        if step.action == "submit":
            return f"submit({step.selector})"
        if step.action == "wait":
            return "wait"
        if step.action == "scroll":
            if step.selector:
                return f"scroll({step.selector})"
            if step.role and step.name:
                return f"scroll({step.role}:{step.name})"
            return "scroll"
        return step.action

    def finalize(self, plan: ExecutionPlan, context: Dict) -> ConstitutionReport:
        """
        Validate navigation results against the navigator constitution.

        Raises:
            ConstitutionViolation: If any critical validation rule fails.

        Returns:
            ConstitutionReport capturing any warnings that callers may surface.
        """
        report = self.constitution.validate(plan, None, context)

        if self.failure_store and (report.failures or report.warnings):
            self.failure_store.save_failure(report)

        if report.warnings:
            log.warning(
                "constitution_warnings",
                agent="A2_Navigator",
                warnings=[w.rule_name for w in report.warnings],
            )

        if not report.passed:
            failure_messages = [f"{f.rule_name}: {f.reason}" for f in report.failures]
            log.error(
                "constitution_failed",
                agent="A2_Navigator",
                failures=[f.rule_name for f in report.failures],
            )
            raise ConstitutionViolation(
                agent="A2_Navigator",
                failures=report.failures,
                message="Navigator constitution failed: " + "; ".join(failure_messages),
            )

        return report

    async def heal(
        self,
        plan: ExecutionPlan,
        context: Dict[str, Any],
        failures: Sequence[ValidationFailure],
    ) -> tuple[bool, Dict[str, Any]]:
        """Attempt basic recovery actions after constitution failure.

        Returns a tuple of (recovered, adjustments). Adjustments may include:
          - start_url: override for the next attempt
          - action_budget: increased budget for retries
          - plan_context: dict merged into interpreter context during retry
          - notes: human-readable notes about actions taken
        """

        adjustments: Dict[str, Any] = {"plan_context": {}, "notes": []}
        recovered = False

        page = context.get("page") or self.page
        action_budget = context.get("action_budget")
        start_url = context.get("start_url")

        if not start_url:
            for step in plan.steps:
                if step.action == "navigate" and step.target:
                    start_url = step.target
                    break

        def _ensure_failure_history() -> Dict[str, list]:
            return adjustments.setdefault("plan_context", {}).setdefault("failure_history", [])

        for failure in failures:
            rule = failure.rule_name
            _ensure_failure_history().append(
                {
                    "rule": rule,
                    "reason": failure.reason,
                    "details": failure.details,
                }
            )

            if rule == "navigation_success":
                target = failure.details.get("final_url") or start_url
                if not target:
                    for step in plan.steps:
                        if step.action == "navigate" and step.target:
                            target = step.target
                            break
                if target:
                    try:
                        await page.goto(target)
                        await page.wait_for_load_state()
                        adjustments["start_url"] = target
                        adjustments.setdefault("notes", []).append(
                            f"Reloaded start URL '{target}' after navigation failure."
                        )
                        recovered = True
                    except Exception as exc:
                        log.warning("navigator_heal_navigation_reload_failed", error=str(exc))

            elif rule == "no_auth_redirects":
                if start_url:
                    try:
                        await page.goto(start_url)
                        await page.wait_for_load_state()
                        adjustments["start_url"] = start_url
                        adjustments.setdefault("notes", []).append(
                            "Auth redirect detected; returned to start URL for retry."
                        )
                        recovered = True
                    except Exception as exc:
                        log.warning("navigator_heal_auth_redirect_failed", error=str(exc))
                adjustments.setdefault("plan_context", {}).setdefault("flags", []).append(
                    "auth_redirect_detected"
                )

            elif rule == "action_budget" and action_budget:
                new_budget = action_budget + 5
                adjustments["action_budget"] = new_budget
                adjustments.setdefault("notes", []).append(
                    f"Increased action budget to {new_budget}."
                )
                recovered = True

        if not adjustments.get("plan_context"):
            adjustments.pop("plan_context", None)
        if not adjustments.get("notes"):
            adjustments.pop("notes", None)

        return recovered, adjustments
